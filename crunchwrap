#!/bin/bash -e

# Copyright (c) 2020 Eli Gladman

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Crunchwrap
# Barebones mustache-like templating written in pure Bash.

# Install
# cp crunchwrap /usr/local/bin/cw && chmod +x /usr/local/bin/cw

# Report Issues
# https://github.com/egladman/crunchwrap/issues

# Introduction
# Crunchwrap works by evaluating existing variables in your environment

# Example
# export FOO="give you up" BAR="let you down" BAZ="run around and desert you"
# echo -e "Never gonna {{ FOO }}. Never gonna {{ BAR }}\nNever Gonna {{ BAZ }}" | cw

readonly cw_pattern_left='{{'
readonly cw_pattern_right='}}'
readonly cw_pattern_left_strict='{{!'
readonly cw_pattern_left_escaped='{{%'

# BRE Regex
readonly regex_crunchwrap_syntax='^(.*)(\{\{[\%|\!]{0,1}[[:space:]][a-zA-Z0-9_]{1,}[[:space:]]\}\})(.*)$'
readonly regex_character_class='^(\[\[\:)(crunchwrap_[a-zA-Z0-9_]{1,})(\:\]\])$'
readonly regex_crunchwrap_strict_syntax='^(.*)(\{\{\![[:space:]][a-zA-Z0-9_]{1,}[[:space:]]\}\})(.*)$'
readonly regex_crunchwrap_escaped_syntax='^(.*)(\{\{\%[[:space:]][a-zA-Z0-9_]{1,}[[:space:]]\}\})(.*)$'

# Non-standard Character Classes
readonly cc_nospace='[[:crunchwrap_nospace:]]'
readonly cc_space='[[:crunchwrap_space:]]'
readonly cc_tab='[[:crunchwrap_tab:]]'
# FIXME: We will run into an issue if read in a line that already contains the
# above strings

CLR_CYAN='\033[36m'
CLR_RED='\033[0;31m'
CLR_NONE='\033[0m' # No color
FL_DEBUG=0

if [[ "${1}" = "-v" ]]; then
    FL_DEBUG=1
fi

_log() {
    printf '%b\n' "${0##*/}: ${1}" 1>&2
}

_debug() {
    if [[ $FL_DEBUG -eq 1 ]]; then
        _log "${CLR_CYAN}DEBUG:${CLR_NONE} ${1}"
    fi
}

_die() {
    # Usage: _die "goodbye cruel world" 128
    _log "${CLR_RED}FATAL:${CLR_NONE} ${1}"

    local rc
    # Default to return code: '1' if nothing is specified
    [[ -z "${2}" ]] && rc=1
    exit $rc
}

_strip_left() {
    # Usage: _strip_left "string" "pattern"
    printf '%s\n' "${1##$2}"
}

_strip_right() {
    # Usage: _strip_right "string" "pattern"
    printf '%s\n' "${1%%$2}"
}

_strip_all() {
    # Usage: _strip_all "string" "pattern"
    printf '%s\n' "${1//$2}"
}

_replace_all() {
    # Usage: _replace_all "string" "pattern" "replace"
    printf '%s\n' "${1//$2/$3}"
}

_replace_first() {
    # Usage: _replace_first "string" "pattern" "replace"
    printf '%s\n' "${1/$2/$3}"
}

_escape_html () {
    # Usage: _esacpe_html "hello & goodbye"
    local string="${1}"
    string=${string//&/&amp;}
    string=${string//</&lt;}
    string=${string//>/&gt;}
    string=${string//'"'/&quot;}
    printf '%s' "${string}"
}

_strip_handlebars() {
    # We can strip using pure bash by breaking it up into steps. Left then Right.
    local string_raw="${1}"
    local string=""

    string_raw=$(_strip_left "${string_raw}" "*${cw_pattern_left} ")
    string=$(_strip_right "${string_raw}" " ${cw_pattern_right}*")

    printf '%s\n' "${string}"
}

_strip_character_classes() {
    local array=("${@}")
    local string=""

    for ((j = 0; j < "${#array[@]}"; j++)); do
        chunk="${array[$j]}"
        case "${chunk}" in
            "${cc_nospace}")
                string+=''
                ;;
            "${cc_tab}")
                string+=$'\t'
                ;;
            "${cc_space}")
                string+=" "
                ;;
            *)
                string+="${chunk}"
                ;;
        esac
    done
    printf '%s\n' "${string}"
}

_eval_tags() {
    # Tags that evaluate to empty strings are treated like any other. As
    # sometimes an empty string is desired in templates. You may override
    # this behavior by using '{{!' instead. This way crunchwrap will
    # return a code > 0

    local string="${*}"
    local cw_variable cw_value

    # Replace '{{<d>' with '{{'                             (d for delimiter)
    # -----------------------------------------------------------------------
    # We must be clever with how we replace '{{%' with '{{'. If we perform
    # a global find/replace we run the risk of inadverently modifying other
    # substrings that contain '{{%' that don't have an accompanying '}}'

    # We're able to make the following assumptions for validate tags:
    # - There will never be any spaces left of '{{%'
    # - There will be a space to the right of '{{%'

    # Given this criteria I can safely perform a find/replace on '{{% '. The
    # space after the delimiter is critical!


    # fail_when_empty | escape_html | import_template
    # -----------------------------------------------------------------------
    # These variables can essentially equal anything. It's set to 'true' for
    # easy readability, further down all we're doing is making sure the variable
    # is set. The actual contents of the variable doesn't matter. See `-v`
    # in man bash.

    if [[ "${string}" =~ $regex_crunchwrap_strict_syntax ]]; then
        fail_when_empty=true
        _debug "var: fail_when_empty='${fail_when_empty}' for string: '${string}'"

        string=$(_replace_first "${string}" "${cw_pattern_left_strict} " "{{ ")
    elif [[ "${string}" =~ $regex_crunchwrap_escaped_syntax ]]; then
        escape_html=true
        _debug "var: escape_html='${escape_html}' for string: '${string}'"

        string=$(_replace_first "${string}" "${cw_pattern_left_escaped} " "{{ ")
    fi

    cw_variable=$(_strip_handlebars "${string}")
    cw_value=$(eval printf '%s' \"\$"${cw_variable}"\")

    if [[ -v fail_when_empty ]] && [[ -z "${cw_value}" ]]; then
        unset fail_when_empty
        _log "environment variable: '${cw_variable}' evaluated to an empty string. Dying. Use '{{ <string> }}' instead of '{{! <string>}}' if this behavior is not desired."
        return 126
    fi

    if [[ -v escape_html ]] && [[ -n "${cw_value}" ]]; then
        unset escape_html
        _debug "Calling func: '_escape_html' with argument: ${cw_value}"
        cw_value=$(_escape_html "${cw_value}")

        _debug "var: cw_value='${cw_value}'"
    fi

    _debug "var: cw_variable='${cw_variable}'"
    _debug "var: cw_value='${cw_value}'"

    # Check for nested crunchwrap tags
    if [[ "${cw_value}" =~ $regex_crunchwrap_syntax ]]; then
        _debug "Found nested tags while evaluating: '${cw_variable}'"
        cw_value=$(printf '%s\n' "${cw_value}" | main)
        # Don't let the above line intimidate you. All we're doing is re-using
        # exsiting code. We could accomplish the same thing with something like:

        # cw_value_old="${cw_value}"
        # cw_value=''
        # while IFS='' read -r line; do
        #     cw_value+="$(_parse "${line}")"
        # done <<< "${cw_value_old}"
    fi

    # Print the string with the resolved tag/variable
    _replace_all "${string}" "${cw_pattern_left} ${cw_variable} ${cw_pattern_right}" "${cw_value}"
}

_parse() {
    local line="${1}"

    # Before we do anything we need to replace all whitespace with specialty
    # character classes that crunchwrap knows to look for
    line=$(_replace_all "${line}" " " " ${cc_space} ") # spaces
    line=$(_replace_all "${line}" $'\t' " ${cc_tab} ") # tabs

    # Take the line that was just read in, and split it into an array
    # Why? there could be multiple crunchrap tags in one line
    IFS=' ' read -r -a line_arr <<< "${line}"

    local line_arr_transformed=()
    local line_fragment_arr=()
    local found_open_tag=0 found_tag_contents=0 found_closed_tag=0
    local line_arr_splice_count=0

    for ((i = 0; i < "${#line_arr[@]}"; i++)); do
        # This might seem counter-intuitive. Here's why don't do:
        # > for line_segment in "${line_arr[@]}"

        # We dynamically add elements to array: 'line_arr'. The loop wouldn't
        # know to look for new elements inserted into the array since the length
        # of '${line_arr[@]}' gets cached at the beginning.
        line_segment="${line_arr[$i]}"

        regex_conjointed_handlebars="^(\}\})(.*)(\{\{)$"
        if [[ "${line_segment}" =~ $regex_conjointed_handlebars ]]; then
            # Check for consecutive crunchwrap variables that aren't delimited by a space:
            # '{{ <string> }}<string>{{ <string> }}'
            #              ^^^^^^^^^^^^
            _debug "Found conjoined left/right patterns: '${line_segment}'. Splitting..."

            local sandwiched_characters
            sandwiched_characters=$(_strip_left "${line_segment}" "}}")
            sandwiched_characters=$(_strip_right "${sandwiched_characters}" "{{")
            # If var: sandwiched_characters is an empty string it won't be included into array: line_arr

            local splice=("}}" "${cc_nospace}" "${sandwiched_characters}" "${cc_nospace}" "{{")
            line_arr=("${line_arr[@]:0:$i}" "${splice[@]}" "${line_arr[@]:$((i+1))}")

            line_arr_splice_count=$((line_arr_splice_count + 1))
            _debug "var: line_arr_splice_count='${line_arr_splice_count}'"

            # Since we've dynamically expanded thearray: line_arr we must
            # manually update var: line_segment
            line_segment="${cw_pattern_right}"
        fi

        # Classify line segment. Does it have any special meaning to crunchwrap
        # or does the segment consist of random characters?
        case "${line_segment}" in
            *"${cw_pattern_left}"|*"${cw_pattern_left_strict}"|*"${cw_pattern_left_escaped}")
                _debug "Found left pattern: '${line_segment}'"
                # We found the left: '{{ <string> }}'
                #                     ^^
                line_fragment_arr+=("${line_segment}")
                found_open_tag=1
                ;;
            "${cw_pattern_right}"*)
                _debug "Found right pattern: '${line_segment}'"
                # We found the right: '{{ <string> }}'
                #                                  ^^
                line_fragment_arr+=("${line_segment}")
                found_closed_tag=1

                # Check for mismatched/lone brackets
                if [[ $found_open_tag -eq 0 && $found_closed_tag -eq 1 ]]; then
                    _debug "Found unmatched handlebars. Ignoring '}}'"
                    found_closed_tag=0
                fi

                # Found matching starting/ending handlebars
                # We just flipped 'found_closed_tag' above, so their no point in checking it
                if [[ $found_open_tag -eq 1 && $found_tag_contents -eq 1 ]]; then
                    _debug "Calling func: _eval_tags with argument: ${line_fragment_arr[*]}"

                    local results
                    results=$(_eval_tags "${line_fragment_arr[*]}")
                    [[ $? -eq 0 ]] || return

                    line_arr_transformed+=("${results}")

                    # Reset. Just in case their are more crunchwrap variables in
                    # the remainder of array: line_arr
                    line_fragment_arr=() # Everything except the first element
                    found_open_tag=0; found_tag_contents=0; found_closed_tag=0
                fi
                ;;
            *)
                if [[ $found_open_tag -eq 0  &&  $found_closed_tag -eq 0 ]]; then
                    # We haven't found '{{' or '}}' so let's keep on going
                    line_arr_transformed+=("${line_segment}")
                elif [[ "${line_segment}" =~ $regex_character_class ]]; then
                    _debug "Ignoring crunchwrap character class: '${line_segment}'"
                elif [[ $found_open_tag -eq 1 && $found_closed_tag -eq 0 ]]; then
                    _debug "Found middle: '${line_segment}'"
                    # We found the middle: '{{ <string> }}'
                    #                          ^^^^^^^^
                    line_fragment_arr+=("${line_segment}")
                    found_tag_contents=1
                fi
                ;;
        esac

        if [[ $((i + 1)) -eq ${#line_arr[@]} ]]; then # We've reached the end of the line
            _debug "[EOL] var: index='$i' element='${line_arr[$i]}' line_arr_length='${#line_arr[@]}' line_arr_splice_count='${line_arr_splice_count}'"
            _debug "[EOL] var: line_arr='${line_arr[*]}'"
            _debug "[EOL] var: line_arr_transformed='${line_arr_transformed[*]}'"

            # The finale. What gets printed to stdout
            _strip_character_classes "${line_arr_transformed[@]}"
        fi
    done
}

main() {
    # By default 'read' trims leading/trailing whitespace. so we must use override IFS
    while IFS='' read -r line; do
        if [[ ! "${line}" =~ $regex_crunchwrap_syntax ]]; then
            # Pass the unaltered string through if it doesn't contain: {{ <string> }}
            _debug "Line doesn't match regex. Passing it through unmodified."
            printf '%s\n' "${line}"
            continue
        fi

        # The 'break' is kinda redundant since errexit is enabled
        _parse "${line}" || break
    done
}

main
